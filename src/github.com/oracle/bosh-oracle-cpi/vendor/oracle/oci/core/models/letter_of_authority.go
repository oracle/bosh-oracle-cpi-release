// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// LetterOfAuthority The Letter of Authority for the cross-connect. You must submit this letter when
// requesting cabling for the cross-connect at the FastConnect location.
//
// swagger:model LetterOfAuthority
type LetterOfAuthority struct {

	// The name of the entity authorized by this Letter of Authority.
	// Max Length: 255
	// Min Length: 1
	AuthorizedEntityName string `json:"authorizedEntityName,omitempty"`

	// The type of cross-connect fiber, termination, and optical specification.
	CircuitType string `json:"circuitType,omitempty"`

	// The OCID of the cross-connect.
	// Max Length: 255
	// Min Length: 1
	CrossConnectID string `json:"crossConnectId,omitempty"`

	// The address of the FastConnect location.
	// Max Length: 255
	// Min Length: 1
	FacilityLocation string `json:"facilityLocation,omitempty"`

	// The meet-me room port for this cross-connect.
	// Max Length: 255
	// Min Length: 1
	PortName string `json:"portName,omitempty"`

	// The date and time when the Letter of Authority expires, in the format defined by RFC3339.
	//
	TimeExpires strfmt.DateTime `json:"timeExpires,omitempty"`

	// The date and time the Letter of Authority was created, in the format defined by RFC3339.
	//
	// Example: `2016-08-25T21:10:29.600Z`
	//
	TimeIssued strfmt.DateTime `json:"timeIssued,omitempty"`
}

// Validate validates this letter of authority
func (m *LetterOfAuthority) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAuthorizedEntityName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCircuitType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCrossConnectID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFacilityLocation(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePortName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTimeExpires(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTimeIssued(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LetterOfAuthority) validateAuthorizedEntityName(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthorizedEntityName) { // not required
		return nil
	}

	if err := validate.MinLength("authorizedEntityName", "body", string(m.AuthorizedEntityName), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("authorizedEntityName", "body", string(m.AuthorizedEntityName), 255); err != nil {
		return err
	}

	return nil
}

var letterOfAuthorityTypeCircuitTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Single_mode_LC","Single_mode_SC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		letterOfAuthorityTypeCircuitTypePropEnum = append(letterOfAuthorityTypeCircuitTypePropEnum, v)
	}
}

const (

	// LetterOfAuthorityCircuitTypeSingleModeLC captures enum value "Single_mode_LC"
	LetterOfAuthorityCircuitTypeSingleModeLC string = "Single_mode_LC"

	// LetterOfAuthorityCircuitTypeSingleModeSC captures enum value "Single_mode_SC"
	LetterOfAuthorityCircuitTypeSingleModeSC string = "Single_mode_SC"
)

// prop value enum
func (m *LetterOfAuthority) validateCircuitTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, letterOfAuthorityTypeCircuitTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *LetterOfAuthority) validateCircuitType(formats strfmt.Registry) error {

	if swag.IsZero(m.CircuitType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCircuitTypeEnum("circuitType", "body", m.CircuitType); err != nil {
		return err
	}

	return nil
}

func (m *LetterOfAuthority) validateCrossConnectID(formats strfmt.Registry) error {

	if swag.IsZero(m.CrossConnectID) { // not required
		return nil
	}

	if err := validate.MinLength("crossConnectId", "body", string(m.CrossConnectID), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("crossConnectId", "body", string(m.CrossConnectID), 255); err != nil {
		return err
	}

	return nil
}

func (m *LetterOfAuthority) validateFacilityLocation(formats strfmt.Registry) error {

	if swag.IsZero(m.FacilityLocation) { // not required
		return nil
	}

	if err := validate.MinLength("facilityLocation", "body", string(m.FacilityLocation), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("facilityLocation", "body", string(m.FacilityLocation), 255); err != nil {
		return err
	}

	return nil
}

func (m *LetterOfAuthority) validatePortName(formats strfmt.Registry) error {

	if swag.IsZero(m.PortName) { // not required
		return nil
	}

	if err := validate.MinLength("portName", "body", string(m.PortName), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("portName", "body", string(m.PortName), 255); err != nil {
		return err
	}

	return nil
}

func (m *LetterOfAuthority) validateTimeExpires(formats strfmt.Registry) error {

	if swag.IsZero(m.TimeExpires) { // not required
		return nil
	}

	if err := validate.FormatOf("timeExpires", "body", "date-time", m.TimeExpires.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *LetterOfAuthority) validateTimeIssued(formats strfmt.Registry) error {

	if swag.IsZero(m.TimeIssued) { // not required
		return nil
	}

	if err := validate.FormatOf("timeIssued", "body", "date-time", m.TimeIssued.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *LetterOfAuthority) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *LetterOfAuthority) UnmarshalBinary(b []byte) error {
	var res LetterOfAuthority
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
